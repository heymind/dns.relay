package dev.idx0;


import lombok.Data;
import lombok.experimental.Accessors;

import java.io.IOException;


/**
 * http://www.tcpipguide.com/free/t_DNSMessageHeaderandQuestionSectionFormat.htm
 */
@Data
@Accessors(chain = true)
public class DNSHeader {
    
    private int OPCode;
    /**
     * Authoritative Answer Flag:
     * This bit is set to 1 in a response to indicate that the server that created the response is authoritative for
     * the zone in which the domain name specified in the Question section is located. If it is 0, the response
     * is non-authoritative.
     */
    private boolean AuthoritativeAnswerFlag = false;
    /**
     * Truncation Flag:
     * When set to 1, indicates that the message was truncated due to its length being longer than the maximum permitted
     * for the type of transport mechanism used. TCP doesn't have a length limit for messages, while UDP messages are
     * limited to 512 bytes, so this bit being sent usually is an indication that the message was sent using UDP and was
     * too long to fit. The client may need to establish a TCP session to get the full message. On the other hand,
     * if the portion truncated was part of the Additional section, it may choose not to bother.
     */
    private boolean TruncationFlag = false;
    /**
     * Recursion Desired:
     * When set in a query, requests that the server receiving the query attempt to answer the query recursively,
     * if the server supports recursive resolution. The value of this bit is not changed in the response.
     */
    private boolean RecursionDesiredFlag = false;
    /**
     * Recursion Available:
     * Set to 1 or cleared to 0 in a response to indicate whether the server creating the response supports recursive
     * queries. This can then be noted by the device that sent the query for future use.
     */
    private boolean RecursionAvailableFlag = false;

    private int ResponseCode;
    
    /**
     * Identifier: A 16-bit identification field generated by the device that creates the DNS query.
     * It is copied by the server into the response, so it can be used by that device to match that query to
     * the corresponding reply received from a DNS server.
     */
    private int ID;
    
    /**
     * Question Count:
     * Specifies the number of questions in the Question section of the message.
     */
    private int QuestionCount = 0;
    /**
     * Answer Record Count:
     * Specifies the number of resource records in the Answer section of the message.
     */
    private int AnswerRecordCount = 0;
    /**
     * Authority Record Count:
     * Specifies the number of resource records in the Authority section of the message.
     */
    private int AuthorityRecordCount = 0;
    /**
     * Additional Record Count:
     * Specifies the number of resource records in the Additional section of the message.
     */
    private int AdditionalRecordCount =0;


    private boolean QueryFlag;


    public static final int OPCODE_QUERY = 0;
    public static final int OPCODE_IQUERY = 1;
    public static final int OPCODE_STATUS = 2;
    public static final int OPCODE_NOTIFY = 4;
    public static final int OPCODE_UPDATE = 5;

    //        NoError(0),
//        FormatError(1),
//        ServerFailure(2),
//        NameError(3),
//        NotImplemented(4),
//        Refused(5),
//        YXDomain(6),
//        YXRRSet(7),
//        NXRRSet(8),
//        NotAuth(9),
//        NotZone(10);

    public static final int RCODE_NO_ERROR = 0;
    public static final int RCODE_FORMAT_ERROR = 1;
    public static final int RCODE_FORMAT_REFUSED = 5;

    DNSHeader(){}
    public DNSHeader(ExtendedDataInputStream in) throws IOException {
        setID(in.readUnsignedShort());
        int flags = in.readUnsignedShort();
        setResponseCode(flags & 0xf);
        flags >>= 7;
        setRecursionAvailableFlag((flags & 1) == 1);
        flags >>= 1;
        setRecursionDesiredFlag((flags & 1) == 1);
        flags >>= 1;
        setTruncationFlag((flags & 1) == 1);
        flags >>= 1;
        setAuthoritativeAnswerFlag((flags & 1) == 1);
        setOPCode(flags & 0xf);
        flags >>= 5;
        setQueryFlag((flags & 1) == 0);

        setQuestionCount(in.readUnsignedShort())
                .setAnswerRecordCount(in.readUnsignedShort())
                .setAuthorityRecordCount(in.readUnsignedShort())
                .setAdditionalRecordCount(in.readUnsignedShort());
    }
    
     void serializeToStream(ExtendedDataOutputStream out) throws IOException{
        out.writeShort((short) getID());
        int flags = isQueryFlag() ? 0 : 1;
        flags <<= 4;
        flags |= getOPCode();
        flags <<= 1;
        flags |= isAuthoritativeAnswerFlag() ? 1 : 0;
        flags <<= 1;
        flags |= isTruncationFlag() ? 1 : 0;
        flags <<= 1;
        flags |= isRecursionDesiredFlag() ? 1 : 0;
        flags <<= 1;
        flags |= isRecursionAvailableFlag() ? 1 : 0;
        flags <<= 7;
        flags |= getResponseCode();
        out.writeShort((short)flags);
        out.writeShort((short) getQuestionCount());
        out.writeShort((short) getAnswerRecordCount());
        out.writeShort((short) getAuthorityRecordCount());
        out.writeShort((short) getAdditionalRecordCount());
    }
    public byte[] toByteArray() throws IOException {
        ExtendedDataOutputStream out = new ExtendedDataOutputStream();
        serializeToStream(out);
        return out.toByteArray();
    }

    

}
